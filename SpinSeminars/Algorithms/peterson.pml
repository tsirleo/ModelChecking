#define N 2

bool flag [N] = 0;
byte turn = 0;

active [N] proctype P() { // определяет процессный тип, active - для двух процессов
  byte i = _pid; // гарантируется, что пиды будут присвоены по порядку (0, 1, 2, ...)
  NCS: printf("NCS %d\n", i); // некритическая секция
  SET: flag[i] = 1; turn = i;
  TST: !((flag[1-i] == 1) && (turn == i)) // в этом случае ждать, если значение равно нулю, 
                                          // то происходит блокировка (+ отрицание)
  CRS: printf("CRS %d\n", i); // критическая секция, skip; - пропустить шаг
  RST: flag[i] = 0; goto NCS;
}
// массивы разрешены только одномерные

// spin peterson.pml - запустить
// -u{количество шагов} - для ограничения количества шагов при запуске

// глобально неверно, что оба процесса находятся в критической секции
// [] - глобально
ltl safety {
  [](!(P[0]@CRS && P[1]@CRS))
}

// глобально, если процесс обратился к критической секции, то рано или поздно он 
// получит к ней доступ
// <> - в будущем
ltl liveness {
  [](P[0]@SET -> <>(P[0]@CRS))
}

// spin -a peterson.pml - генерация, в том числе программы проверки на С
// gcc -o pan pan.c - скомпилировать программу проверки
// ./pan запустить проверку формулы, проверяется формула safety, errors: 0
// ./pan -a -N liveness - чтобы проверить другую клаузу
// по умолчанию программа не ищет допускающие циклы - это проверка свойства живости, 
// поэтому чтобы проверить свойство живости нужно запускать с -a
// -f для указания того, что планировщик справедливый

// в liveness ошибка - нулевой процесс хочет войти в критическую секцию, но ему не дают
// c -f планировщик справедливый и ошибки в liveness нет

// spin -t peterson.pml - проверить где ошибка (трейл)
// spin -t -p peterson.pml - со строчками кода